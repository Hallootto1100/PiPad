from RPiMCP23S17.MCP23S17 import MCP23S17
import time
import threading
import RPi.GPIO as GPIO
import uinput


class Pin():
    PIN_IN = 0
    PIN_OUT = 1

    def __init__(self, pinNr):
        self.pinNr = pinNr
        self.callback = self.stdCallback

    def setupDir(self, direction):
        self.direction = direction
        print('Error: function not overwritten...')

    def setState(self, state):
        self.state = state
        print('Error: function not overwritten...')

    def getState(self):
        print('Error: function not overwritten...')
        return self.state

    def registerCallback(self, callback):
        self.callback = callback
        print('Error: function not overwritten...')

    def stdCallback(self):
        print('Warning: Base callback called')



class PinGPIO(Pin):
    PIN_GPIO_BOUNCETIME = 3

    def __init__(self, pinNr):
        self.pinNr = pinNr
        self.state = False
        self.direction = Pin.PIN_IN,
        GPIO.setmode(GPIO.BOARD)

    def setupDir(self, direction):
        self.direction = direction
        if Pin.PIN_IN == direction:
            GPIO.setup(channel=self.pinNr, direction=GPIO.IN, pull_up_down=GPIO.PUD_UP)
        else:
            GPIO.setup(channel=self.pinNr, direction=GPIO.OUT)

    def setState(self, state):
        assert Pin.PIN_OUT == self.direction
        GPIO.output(self.pinNr, state)
        self.state = state

    def getState(self):
        self.state = GPIO.input(self.pinNr)
        return self.state
        
    def registerCallback(self, callback):
        self.callback = callback
        GPIO.add_event_detect(self.pinNr, GPIO.BOTH, callback = self._gpioCallback, bouncetime=PinGPIO.PIN_GPIO_BOUNCETIME)

    def _gpioCallback(self, channel):
        state = GPIO.input(self.pinNr)
        if self.state == state:
            return
        self.state = state
        self.callback()

class PinExp(Pin):
    PIN_EXP_SPI_SPEED = 1000000
    PIN_INTERRUPT_GPIO = 37

    def __init__(self, pinNr, expander):
        self.pinNr = pinNr
        self.expander = expander
        self.state = False
        self.direction = Pin.PIN_IN
        
    def setupDir(self, direction):
        self.direction = direction
        if Pin.PIN_IN == self.direction:
            self.expander.setDirection(self.pinNr, MCP23S17.DIR_INPUT)
            self.expander.setPullupMode(self.pinNr, MCP23S17.PULLUP_ENABLED)
        else:
            self.expander.setDirection(self.pinNr, MCP23S17.DIR_OUTPUT)

    def setState(self, state):
        assert Pin.PIN_OUT == self.direction
        self.expander.digitalWrite(self.pinNr, state)
        self.state = state

    def getState(self):
        self.state = self.expander.digitalRead(self.pinNr)
        return self.state

    def registerCallback(self, callback):
        self.callback = callback
        self.expander.registerInterrupt(self)

    def expCallback(self):
        self.callback(channel=self.pinNr)

class Expander(MCP23S17):
    EXP_IPOLA_EN  = 0x02
    EXP_IPOLB_EN  = 0x03
    EXP_GPINTA_EN = 0x04
    EXP_GPINTB_EN = 0x05
    EXP_INTCONA   = 0x08
    EXP_INTCONB   = 0x09
    EXP_INTFA     = 0x0E
    EXP_INTFB     = 0x0F
    EXP_INTCAPA   = 0x10
    EXP_INTCAPB   = 0x11

    EXP_WATCH_INTERVAL = 0.1

    def __init__(self, bus, cs, address, interruptPin=-1):
        super().__init__(bus=bus, pin_cs = cs, device_id=address)
        self.interruptPins = []
        self.interruptOccured = False
        self.inputReg = 0x0000
        self.outputReg = 0x0000
        self._watchdog()

        # setup interrupt if available
        if -1 != interruptPin:
            GPIO.setup(interruptPin, direction=GPIO.IN, pull_up_down=GPIO.PUD_OFF)
            GPIO.add_event_detect(interruptPin, GPIO.RISING, callback=self._interruptCallback)

    def open(self, speed):
        # opens the serial port with choosen speed. max 10MHz
        super().open()
        self._spi.max_speed_hz = speed
        self._writeRegister(Expander.EXP_GPINTA_EN, 0x00)
        self._writeRegister(Expander.EXP_GPINTB_EN, 0x00)
        self._writeRegister(Expander.EXP_INTCONA, 0x00)
        self._writeRegister(Expander.EXP_INTCONB, 0x00)
        self._writeRegister(Expander.EXP_IPOLA_EN, 0x00)
        self._writeRegister(Expander.EXP_IPOLB_EN, 0x00)
        self._writeRegister(MCP23S17.MCP23S17_IOCON, MCP23S17.IOCON_INIT | MCP23S17.IOCON_MIRROR | MCP23S17.IOCON_INTPOL)
        self.inputReg = self.readGPIO()

    def registerInterrupt(self, pin:PinExp):
        # registrate input pin for interrupt handling
        pinNr = pin.pinNr
        assert self.isInitialized
        assert pinNr < 16
        regAddr = 0

        if(pinNr < 8):
            regAddr = Expander.EXP_GPINTA_EN
        else:
            regAddr = Expander.EXP_GPINTB_EN

        self.setDirection(pinNr, MCP23S17.DIR_INPUT)

        regValue = self._readRegister(regAddr)
        print('old value at reg 0x%x was 0x%x' % (regAddr, regValue))
        regValue |= 1<<pinNr
        self._writeRegister(regAddr, regValue)
        print('new value at reg 0x%x is 0x%x' % (regAddr, regValue))

        self.interruptPins.append(pin)

    def _interruptCallback(self, channel):
        self.interruptOccured = True

    def _watchdog(self):
        # thread for periodicaly synchronize and update the expander
        self.thread = threading.Timer(Expander.EXP_WATCH_INTERVAL, self._watchdog)
        self.thread.start()
        
        #check if interrupt occured -> button pressed
        if self.interruptOccured:
            inPortA = self._readRegister(MCP23S17.MCP23S17_GPIOA)
            inPortB = self._readRegister(MCP23S17.MCP23S17_GPIOB)
            interruptFlags = (inPortA ^ self.inPortA) + ((inPortB ^ self.inPortB) << 8)
            self.inPortA = inPortA
            self.inPortB = inPortB
            for pin in self.interruptPins:
                if interruptFlags & (1<<pin.pinNr):
                    pin.expCallback()


class Button():
    def __init__(self, input:Pin, led:Pin, name:str, keyCode, keyboard:uinput.Device):
        self.input = input
        self.input.setupDir(Pin.PIN_IN)
        self.input.registerCallback(self.buttonEventCallback)
        
        self.led = led
        self.led.setupDir(Pin.PIN_OUT)
        self.led.setState(True)

        self.name = name
        self.keyCode = keyCode
        self.keyboard = keyboard

    def buttonEventCallback(self, channel=0):
        if self.input.getState():
            self.buttonReleased()
        else:
            self.buttonPressed()

    def buttonPressed(self):
        print('pressed button %s -> keycode=%s'%(self.name, self.keyCode))
        self.keyboard.emit(self.keyCode, 1)
        self.led.setState(False)

    def buttonReleased(self):
        self.keyboard.emit(self.keyCode, 0)
        self.led.setState(True)

class JoyStick():
    def __init__(self, up, down, left, right):
        self.up = up
        self.up.setupDir(Pin.PIN_IN)
        self.up.registerCallback(self.upChanged)
    
        self.down = down
        self.down.setupDir(Pin.PIN_IN)
        self.down.registerCallback(self.downChanged)
    
        self.left = left
        self.left.setupDir(Pin.PIN_IN)
        self.left.registerCallback(self.leftChanged)
    
        self.right = right
        self.right.setupDir(Pin.PIN_IN)
        self.right.registerCallback(self.rightChanged)

    def upChanged(self, channel=0):
        if self.up.getState():
            print('up pressed')
        else:
            print('up released')

    def downChanged(self, channel=0):
        if self.down.getState():
            print('down pressed')
        else:
            print('down released')

    def leftChanged(self, channel=0):
        if self.left.getState():
            print('left pressed')
        else:
            print('left released')

    def rightChanged(self, channel=0):
        if self.right.getState():
            print('right pressed')
        else:
            print('right released')


class Player():
    def __init__(self):
        self.buttons = []
        self.joysticks = []
        self.keyboard = None

    def setupKeyboard(self):
        events = []
        for b in self.buttons:
            events.append(b.keyCode)
        self.keyboard = uinput.Device(events)    
        print('device initialized') 
        for b in self.buttons:
            b.keyboard = self.keyboard
            
    def addButton(self, config):
        for buttonConfig in config:
            if buttonConfig['inSource'] != 0:
                inPin = PinExp(buttonConfig['inPin'], buttonConfig['inSource'])
            else:
                inPin = PinGPIO(buttonConfig['inPin'])
            
            if buttonConfig['ledSource'] != 0:
                ledPin = PinExp(buttonConfig['ledPin'], buttonConfig['ledSource']) 
            else:
                ledPin = PinGPIO(buttonConfig['ledPin'])
            
            button = Button(inPin, ledPin, buttonConfig['name'], buttonConfig['keyCode'], self.keyboard)
            self.buttons.append(button)

    def addJoystick(self, config):
        for joyConf in config:
            up = PinGPIO(joyConf['up'])
            down = PinGPIO(joyConf['down'])
            left = PinGPIO(joyConf['left'])
            right = PinGPIO(joyConf['right'])
            joy = JoyStick(up, down, left, right)
            self.joysticks.append(joy)

        
    

if __name__ == "__main__":
    GPIO.setmode(GPIO.BOARD)
    exp0 = Expander(0, 0, 0, interruptPin=37)
    exp1 = Expander(0, 1, 4)
    exp0.open(10000000)
    exp1.open(10000000)

    buttonPlayer0 = [
        {'inPin' : 0,    'inSource' : exp0,  'ledPin' : 1,   'ledSource' : exp0,    'keyCode' : uinput.KEY_SPACE,     'name' : 'select'},
        {'inPin' : 2,    'inSource' : exp0,  'ledPin' : 3,   'ledSource' : exp0,    'keyCode' : uinput.KEY_ENTER,     'name' : 'start'},
        {'inPin' : 3,    'inSource' : 0,     'ledPin' : 2,   'ledSource' : exp1,    'keyCode' : uinput.KEY_A,         'name' : 'a'},
        {'inPin' : 5,    'inSource' : 0,     'ledPin' : 3,   'ledSource' : exp1,    'keyCode' : uinput.KEY_B,         'name' : 'b'},
        {'inPin' : 7,    'inSource' : 0,     'ledPin' : 4,   'ledSource' : exp1,    'keyCode' : uinput.KEY_X,         'name' : 'x'},
        {'inPin' : 11,   'inSource' : 0,     'ledPin' : 5,   'ledSource' : exp1,    'keyCode' : uinput.KEY_Y,         'name' : 'y'},
        {'inPin' : 15,   'inSource' : 0,     'ledPin' : 7,   'ledSource' : exp1,    'keyCode' : uinput.KEY_L,         'name' : 'r'},
        {'inPin' : 13,   'inSource' : 0,     'ledPin' : 6,   'ledSource' : exp1,    'keyCode' : uinput.KEY_R,         'name' : 'l'}
    ]

    joyStickPlayer0 = [
        {'up' : 32, 'down' : 36, 'left' : 38, 'right' : 40}
    ]

    player0 = Player()
    player0.addButton(buttonPlayer0)
    player0.addJoystick(joyStickPlayer0)
    player0.setupKeyboard()

    buttonPlayer1 = [
        {'inPin' : 12,   'inSource' : exp0,  'ledPin' : 13,  'ledSource' : exp0,     'keyCode' : uinput.KEY_SPACE,     'name' : 'select'},
        {'inPin' : 10,   'inSource' : exp0,  'ledPin' : 11,  'ledSource' : exp0,     'keyCode' : uinput.KEY_ENTER,     'name' : 'start'},
        {'inPin' : 8,    'inSource' : 0,     'ledPin' : 13,  'ledSource' : exp1,     'keyCode' : uinput.KEY_A,         'name' : 'a'},
        {'inPin' : 10,   'inSource' : 0,     'ledPin' : 12,  'ledSource' : exp1,     'keyCode' : uinput.KEY_B,         'name' : 'b'},
        {'inPin' : 12,   'inSource' : 0,     'ledPin' : 11,  'ledSource' : exp1,     'keyCode' : uinput.KEY_X,         'name' : 'x'},
        {'inPin' : 16,   'inSource' : 0,     'ledPin' : 10,  'ledSource' : exp1,     'keyCode' : uinput.KEY_Y,         'name' : 'y'},
        {'inPin' : 22,   'inSource' : 0,     'ledPin' : 8,   'ledSource' : exp1,     'keyCode' : uinput.KEY_L,         'name' : 'r'},
        {'inPin' : 18,   'inSource' : 0,     'ledPin' : 9,   'ledSource' : exp1,     'keyCode' : uinput.KEY_R,         'name' : 'l'}
    ]

    joyStickPlayer1 = [
        {'up' : 35, 'down' : 33, 'left' : 31, 'right' : 29}
    ]

    player1 = Player()
    player1.addButton(buttonPlayer1)
    player1.addJoystick(joyStickPlayer1)
    player1.setupKeyboard()

    
    




    while True:
        pass